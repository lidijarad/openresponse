# -*- coding: utf-8 -*-
import re
import ast
import logging
import pkg_resources
from enum import Enum
from django.utils.translation import ugettext_lazy as _
from django.urls import reverse
from xblock.core import XBlock
from xblock.fields import Scope, String, List, Boolean
from xblock.fragment import Fragment
from xblock.validation import ValidationMessage
from xblockutils.studio_editable import StudioEditableXBlockMixin
from xblockutils.settings import XBlockWithSettingsMixin
from xblockutils.resources import ResourceLoader
from django.contrib.auth.models import User
from openedx.core.djangoapps.user_api.preferences.api import get_user_preference
from openedx.core.djangoapps.lang_pref import LANGUAGE_KEY
from xmodule.modulestore.django import modulestore
from opaque_keys import InvalidKeyError
from submissions.models import Submission
from submissions import api
logger = logging.getLogger(__name__)
loader = ResourceLoader(__name__)


@XBlock.needs("field-data")
@XBlock.needs("i18n")
class RecapXBlock(StudioEditableXBlockMixin, XBlock, XBlockWithSettingsMixin):
    """
    RecapXblock allows users to download a PDF copy of their answers to supported
    Xblock types. Supported types include freetextresponse and "problem".
    """

    display_name = String(
        display_name="Display Name",
        help="This is the name of the component",
        scope=Scope.settings,
        default="Recap"
    )

    xblock_list = List(
        display_name="Problems",
        help="Component ID's of the XBlocks you wish to include in the summary.",
        allow_reset=False,
        scope=Scope.settings
    )

    string_html = String(
        display_name="Layout",
        help="Include HTML formatting (introductory paragraphs or headings)that"
        " you would like to accompany the summary of questions and answers.",
        multiline_editor='html',
        default="<p>[[CONTENT]]</p>",
        scope=Scope.settings
    )

    allow_download = Boolean(
        display_name="Allow Download",
        help="Allow the user to download a pdf summary",
        default=True,
        scope=Scope.settings,
    )

    download_text = String(
        display_name="Download Button Text",
        help="Text to display on the download button",
        default="Download",
        scope=Scope.settings,
    )

    html_file = String(
        display_name="HTML File.",
        help="""
            Custom html template to wrap the content generated by the Xblock.
            If you have uploaded a file, the layout section will be deactivated.
        """,
        default=None,
        scope=Scope.settings,
    )

    css_file = String(
        display_name="CSS File.",
        help="CSS file that allow to modify the style content for the student view.",
        default=None,
        scope=Scope.settings,
    )

    editable_fields = (
        'display_name',
        'xblock_list',
        'html_file',
        'css_file',
        'string_html',
        'allow_download',
        'download_text',
    )
    show_in_read_only_mode = True

    def get_recap_course_blocks(self, course_key):
        """
        Retrieve all XBlocks in the course for a particular category.

        Returns only XBlocks that are published and haven't been deleted.
        """
        # Note: we need to check if found components have been orphaned
        # due to a bug in split modulestore (PLAT-799).  Once that bug
        # is resolved, we can skip the `_is_in_course_tree()` check entirely.
        return [
            block for block in modulestore().get_items(
                course_key,
                qualifiers={"category": "recap"},
            )
        ]

    def validate_field_data(self, validation, data):
        """
        Validate this block's field data. We are validating that the chosen
        freetextresponse xblocks ID's exist in the course
        """
        for x_id, x_type in data.xblock_list:
            try:
                usage_key =\
                    self.scope_ids.usage_id.course_key.make_usage_key(
                        x_type,
                        x_id
                    )
                self.runtime.get_block(usage_key)
            except Exception as e:
                logger.warn(e)
                validation.add(
                    ValidationMessage(
                        ValidationMessage.ERROR,
                        u"Component freetextresponse ID: {} does not exist.".format(x_id)
                    )
                )

    def resource_string(self, path):
        """Handy helper for getting resources from our kit."""
        data = pkg_resources.resource_string(__name__, path)
        return data.decode("utf8")

    def get_blocks(self, xblock_list):
        for x_id, x_type in xblock_list:
            try:
                usage_key = \
                    self.scope_ids.usage_id.course_key.make_usage_key(
                        x_type,
                        x_id
                    )
                yield usage_key, x_type
            except InvalidKeyError:
                pass

    def get_blocks_filtering_list(self, xblock_list):
        filter_list = []
        for x_id, x_type in xblock_list:
            try:
                usage_key = \
                    self.scope_ids.usage_id.course_key.make_usage_key(
                        x_type,
                        x_id
                    )
                filter_list.append(usage_key)
            except InvalidKeyError:
                pass
        return filter_list

    def get_submission_key(self, usage_key, user=None):
        """
        Returns submission key needed for submissions api
        """
        try:
            logger.info('Attempting to retrieve student item dictionary.')
            if not user:
                user = self.runtime.get_real_user(self.runtime.anonymous_student_id)

            student_item_dictionary = dict(
                student_id=user.id,
                course_id=str(usage_key.course_key),
                item_id=str(usage_key),
                item_type=usage_key.block_type,
            )
        except AttributeError:
            student_item_dictionary = ''
            logger.error('Studio cannot access self.runtime.get_real_user')
        return student_item_dictionary

    def get_submission(self, usage_key, user=None):
        """
        Returns submission from submissions api
        """
        try:
            submission_key = self.get_submission_key(usage_key, user)
            submission = api.get_submissions(submission_key, limit=1)
            if submission is not None:
                logger.info(
                    'Attempting to retreive submission from submissions api.'
                )
            value = submission[0]["answer"]
        except IndexError:
            logger.warn(
                'IndexError: no submssion matched given student item dict.'
            )
            value = _("Nothing to recap.")
        return value

    def get_display_answer(self, answer):
        """
        Returns formatted answer or placeholder string
        """
        answer_str = _("Nothing to recap.")
        if answer:
            answer_str = re.sub(r'\n+', '<div></div>', str(answer))
        return answer_str

    @XBlock.supports("multi_device")
    def student_view(self, context=None):
        """
        The primary view of the RecapXBlock seen in LMS
        """
        blocks = []
        for usage_key, xblock_type in self.get_blocks(self.xblock_list):
            block = self.runtime.get_block(usage_key)

            if hasattr(block, 'custom_report_format'):
                question = str(block.display_name)

                try:
                    user = self.runtime.get_real_user(self.runtime.anonymous_student_id)
                except TypeError:
                    user = None

                answer = block.custom_report_format(
                    user=user,
                    block=block,
                )

                blocks.append((question, answer))
            elif xblock_type == 'problem':
                answer = u""
                question = u""
                try:
                    question = str(block.display_name)
                    answer = self.get_submission(usage_key)
                    if answer is None:
                        answer = block.lcp.get_question_answer_text()
                    blocks.append((question, answer))
                except Exception as e:
                    logger.warn(str(e))
                    answer = block.lcp.get_question_answer_text()
                    blocks.append((question, answer))

        layout = self.get_user_layout(blocks)

        idArray = self.scope_ids.usage_id._to_string().split('@')
        xblockId = idArray[len(idArray) - 1]
        context = {
            'recap_answers_id': 'recap_answers_' + xblockId,
            'recap_editor_id': 'recap_editor_' + xblockId,
            'recap_cmd_id': 'recap_cmd_' + xblockId,
            'blocks': blocks,
            'layout': layout,
            'allow_download': self.allow_download,
            'download_text': self.download_text,
        }

        frag = Fragment(
            loader.render_django_template(
                "static/html/recap.html",
                context).format(self=self)
        )
        if (self.css_file):
            frag.add_css(self.css_file)

        frag.add_css(self.resource_string("static/css/recap.css"))
        frag.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/FileSaver.js/FileSaver.min.js'
            )
        )
        frag.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/jsPDF-1.3.2/jspdf.min.js'
            )
        )

        frag.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/jsPDF-1.3.2/html2canvas.min.js'
            )
        )
        frag.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/jsPDF-1.3.2/html2pdf.js'
            )
        )

        frag.add_javascript(self.resource_string("static/js/src/recap.js"))
        frag.initialize_js('RecapXBlock', {
            'recap_answers_id': 'recap_answers_' + xblockId,
            'recap_editor_id': 'recap_editor_' + xblockId,
            'recap_cmd_id': 'recap_cmd_' + xblockId,
        })

        return frag

    def get_blocks_list(self, user, block_list):
        blocks = []
        for usage_key, xblock_type in self.get_blocks(block_list):
            try:
                block = self.runtime.get_block(usage_key)

                if hasattr(block, 'custom_report_format'):
                    question = str(block.display_name)
                    answer = block.custom_report_format(
                        user=user,
                        block=block,
                    )
                    blocks.append((question, answer))
                elif xblock_type == 'problem':
                    answer = ""
                    question = ""
                    try:
                        question = str(block.display_name)
                        answer = self.get_submission(usage_key, user)
                        blocks.append((question, answer))
                    except Exception as e:
                        blocks.append((str(usage_key), str(e)))
            except Exception as e:
                logger.warn(str(e))
        return blocks

    def get_user_layout(self, blocks, user=None):
        '''
        For the Recap Instructor dashboard, get HTML layout of user's answers
        '''

        def update_layout(layout, pattern, layout_type):
            '''
            '''
            block_sets = []
            current = 0
            for m in re.finditer(pattern, layout):
                try:
                    title = blocks[int(m.group(1)) - 1][0]
                    answer = blocks[int(m.group(1)) - 1][1]

                    if layout_type == LayoutType.BLOCKS:
                        subblocks = []
                        for x in range(current, current + int(m.group(1))):
                            if len(blocks) > x:
                                subblocks.append((blocks[x][0], blocks[x][1]))
                                current += 1
                        answers = [block_layout.format(q, self.get_display_answer(a)) for q, a in subblocks]
                        qa_str = str(''.join(answers))
                    elif layout_type == LayoutType.SINGLE_BLOCK:
                        qa_str = str(block_layout).format(title, self.get_display_answer(answer))
                    elif layout_type == LayoutType.TITLE:
                        qa_str = title
                    elif layout_type == LayoutType.ANSWER:
                        qa_str = str(self.get_display_answer(answer))

                    block_sets.append((m.start(0), m.end(0), qa_str))
                except IndexError as error:
                    logger.info('Update layout error: %s', error)
                    pass

            for start, end, string in reversed(block_sets):
                layout = layout[0:start] + string + layout[end:]

            return layout

        template = self.html_file if self.html_file else self.string_html

        block_layout = (
            '<p class="recap_question"><strong>{}</strong></p>'
            '<div class="recap_answer" '
            'style="page-break-before:always">{}</div>'
        )
        qa_str = str(
            ''.join(
                str(block_layout).format(
                    q,
                    self.get_display_answer(a)
                ) for q, a in blocks
            )
        )
        layout = template.replace('[[CONTENT]]', qa_str)

        pattern = re.compile(r'\[\[SINGLEBLOCK\(([0-9]+)\)\.(TITLE)\]\]')
        layout = update_layout(layout, pattern, LayoutType.TITLE)
        pattern = re.compile(r'\[\[SINGLEBLOCK\(([0-9]+)\)\.(ANSWER)\]\]')
        layout = update_layout(layout, pattern, LayoutType.ANSWER)

        pattern = re.compile(r'\[\[SINGLEBLOCK\(([0-9]+)\)\]\]')
        layout = update_layout(layout, pattern, LayoutType.SINGLE_BLOCK)

        pattern = re.compile(r'\[\[BLOCKS\(([0-9]+)\)\]\]')
        return update_layout(layout, pattern, LayoutType.BLOCKS)

    def studio_view(self, context):
        """
        Render a form for editing this XBlock
        """
        frag = Fragment()
        context = {
            'fields': [],
            'xblock_list': self.xblock_list,
        }
        # Build a list of all the fields that can be edited:
        for field_name in self.editable_fields:
            field = self.fields[field_name]
            assert field.scope in (Scope.content, Scope.settings), (
                "Only Scope.content or Scope.settings fields can be used with "
                "StudioEditableXBlockMixin. Other scopes are for user-specific data and are "
                "not generally created/configured by content authors in Studio."
            )
            field_info = self._make_field_info(field_name, field)
            if field_info is not None:
                context["fields"].append(field_info)
        frag.content = loader.render_django_template("static/html/recap_edit.html", context)
        frag.add_javascript(loader.load_unicode("static/js/src/recap_edit.js"))
        frag.initialize_js('StudioEditableXBlockMixin')
        return frag

    def recap_blocks_listing_view(self, context=None):
        """This view is used in the Racap tab in the LMS Instructor Dashboard
        to display all available course Recap xblocks.

        Args:
            context: contains two items:
                "recap_items" - all course items with names and parents, example:
                    [{"parent_name": "Vertical name",
                      "name": "Recap Display Name",
                     }, ...]
        Returns:
            (Fragment): The HTML Fragment for this XBlock.
        """
        course_id = self.location.course_key
        recap_blocks = self.get_recap_course_blocks(course_id)
        recap_name_list = []

        for block in recap_blocks:
            recap_name_list.append((block.display_name, block.xblock_list))

        make_pdf_json = reverse('xblock_handler', args=[course_id, block.location, 'make_pdf_json'])
        refresh_table = reverse('xblock_handler', args=[course_id, block.location, 'refresh_table'])

        user = self.runtime.get_real_user(self.runtime.anonymous_student_id)
        lang_prefs = get_user_preference(user, LANGUAGE_KEY)

        context_dict = {
            "make_pdf_json": make_pdf_json,
            "refresh_table": refresh_table,
            "recap_name_list": recap_name_list,
            "lang_prefs": lang_prefs
        }

        instructor_dashboard_fragment = Fragment()
        instructor_dashboard_fragment.content = loader.render_django_template(
            'static/html/recap_dashboard.html',
            context_dict
        )
        instructor_dashboard_fragment.add_css(
            self.resource_string("static/css/recap.css")
        )
        instructor_dashboard_fragment.add_css(
            self.resource_string("public/DataTables/css/jquery.dataTables.css")
        )
        instructor_dashboard_fragment.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/FileSaver.js/FileSaver.min.js'
            )
        )
        instructor_dashboard_fragment.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/jsPDF-1.3.2/jspdf.min.js'
            )
        )
        instructor_dashboard_fragment.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/jsPDF-1.3.2/html2canvas.min.js'
            )
        )
        instructor_dashboard_fragment.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/jsPDF-1.3.2/html2pdf.js'
            )
        )
        instructor_dashboard_fragment.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                'public/DataTables/js/jquery.dataTables.js'
            )
        )

        instructor_dashboard_fragment.add_javascript_url(
            self.runtime.local_resource_url(
                self,
                "public/recap_dashboard.js"
            )
        )
        instructor_dashboard_fragment.initialize_js('RecapDashboard')

        return instructor_dashboard_fragment

    @XBlock.json_handler
    def make_pdf_json(self, data, suffix=''):

        '''
        This is a XBlock json handler for the async pdf download
        '''
        user = User.objects.get(id=data['user_id'])
        which_blocks = ast.literal_eval(data['these_blocks'])
        blocks = self.get_blocks_list(user, which_blocks)
        html = self.get_user_layout(blocks, user)

        if self.css_file:
            html = '<style>{}</style>{}'.format(self.css_file, html)

        if "<h3>" in html:
            html = re.sub("<h3>(.*?)<\/h3>","<h3>{}</h3>".format(data['document_heading']), html)
        else:
            html = u"<h3>{}</h3> \n {}".format(str(data['document_heading']), str(html))

        return {'html': html, 'user_name': user.username}

    @XBlock.json_handler
    def refresh_table(self, data, suffix=''):
        """ Complete HTML view of the XBlock, for refresh by client """
        course_id = self.location.course_key
        recap_blocks = self.get_recap_course_blocks(course_id)
        selected_recap_index = data["recap_id"]

        block_ids = []
        for block in recap_blocks:
            block_ids.append(self.get_blocks_filtering_list(block.xblock_list))

        query_list = []
        for block_id in block_ids[selected_recap_index]:
            query_list.append(Submission.objects.filter(
                student_item__item_id=block_id
            ).values_list('student_item__student_id', flat=True))

        student_ids_intersection = list(set.intersection(*map(set, query_list)))

        downloadable_users = User.objects.filter(
            courseenrollment__course_id=course_id,
            courseenrollment__is_active=1,
            id__in=map(int, student_ids_intersection)
        ).values('username', 'email', 'id')

        return {'data': list(downloadable_users)}

    @staticmethod
    def workbench_scenarios():
        """A canned scenario for display in the workbench."""
        return [
            ("RecapXBlock",
             """<recap/>
             """),
            ("Multiple RecapXBlock",
             """<vertical_demo>
                <recap/>
                <recap/>
                <recap/>
                </vertical_demo>
             """),
        ]


class LayoutType(Enum):
    """
    """
    BLOCKS = 0
    SINGLE_BLOCK = 1
    ANSWER = 2
    TITLE = 3
